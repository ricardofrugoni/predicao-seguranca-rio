"""
üìà AN√ÅLISE TEMPORAL - Tend√™ncias e Sazonalidade
==============================================

P√°gina para an√°lise temporal detalhada com decomposi√ß√£o, tend√™ncias e sazonalidade.
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

def load_sample_data():
    """Carrega dados de exemplo"""
    np.random.seed(42)
    datas = pd.date_range(start='2020-01-01', end='2024-12-31', freq='MS')
    
    # Simula diferentes tipos de crime
    crimes = ['Homic√≠dio Doloso', 'Roubo de Ve√≠culo', 'Roubo a Transeunte', 'Furto de Ve√≠culo']
    regioes = ['Centro', 'Zona Sul', 'Zona Norte', 'Barra da Tijuca']
    
    dados = []
    for crime in crimes:
        for regiao in regioes:
            for data in datas:
                # Tend√™ncia + sazonalidade + ru√≠do
                tendencia = 50 + np.random.normal(0, 10)
                sazonalidade = 10 * np.sin(data.month * 2 * np.pi / 12)
                ruido = np.random.normal(0, 5)
                
                valor = max(0, tendencia + sazonalidade + ruido)
                
                dados.append({
                    'data': data,
                    'tipo_crime': crime,
                    'regiao_administrativa': regiao,
                    'total_ocorrencias': int(valor),
                    'populacao': np.random.randint(100000, 500000),
                    'taxa_100k': valor / 1000 * 100
                })
    
    return pd.DataFrame(dados)

def decompose_time_series(serie):
    """Decomp√µe s√©rie temporal"""
    try:
        from statsmodels.tsa.seasonal import seasonal_decompose
        
        # Converte para s√©rie temporal
        ts = pd.Series(serie, index=pd.date_range(start='2020-01-01', periods=len(serie), freq='MS'))
        
        # Decomposi√ß√£o
        decomposition = seasonal_decompose(ts, model='additive', period=12)
        
        return {
            'trend': decomposition.trend,
            'seasonal': decomposition.seasonal,
            'residual': decomposition.resid,
            'observed': decomposition.observed
        }
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Erro na decomposi√ß√£o: {str(e)}")
        return None

def create_decomposition_chart(decomposition):
    """Cria gr√°fico de decomposi√ß√£o"""
    fig = make_subplots(
        rows=4, cols=1,
        subplot_titles=('S√©rie Original', 'Tend√™ncia', 'Sazonalidade', 'Res√≠duos'),
        vertical_spacing=0.05
    )
    
    # S√©rie original
    fig.add_trace(
        go.Scatter(x=decomposition['observed'].index, y=decomposition['observed'], 
                  name='Original', line=dict(color='blue')),
        row=1, col=1
    )
    
    # Tend√™ncia
    fig.add_trace(
        go.Scatter(x=decomposition['trend'].index, y=decomposition['trend'], 
                  name='Tend√™ncia', line=dict(color='red')),
        row=2, col=1
    )
    
    # Sazonalidade
    fig.add_trace(
        go.Scatter(x=decomposition['seasonal'].index, y=decomposition['seasonal'], 
                  name='Sazonalidade', line=dict(color='green')),
        row=3, col=1
    )
    
    # Res√≠duos
    fig.add_trace(
        go.Scatter(x=decomposition['residual'].index, y=decomposition['residual'], 
                  name='Res√≠duos', line=dict(color='orange')),
        row=4, col=1
    )
    
    fig.update_layout(height=800, showlegend=False, title_text="Decomposi√ß√£o da S√©rie Temporal")
    fig.update_xaxes(title_text="Data", row=4, col=1)
    
    return fig

def create_seasonality_analysis(serie):
    """An√°lise de sazonalidade"""
    # Agrupa por m√™s
    df_mes = pd.DataFrame({
        'mes': pd.date_range(start='2020-01-01', periods=len(serie), freq='MS').month,
        'valor': serie
    })
    
    # Estat√≠sticas por m√™s
    stats_mes = df_mes.groupby('mes')['valor'].agg(['mean', 'std', 'count']).reset_index()
    stats_mes['mes_nome'] = stats_mes['mes'].map({
        1: 'Jan', 2: 'Fev', 3: 'Mar', 4: 'Abr', 5: 'Mai', 6: 'Jun',
        7: 'Jul', 8: 'Ago', 9: 'Set', 10: 'Out', 11: 'Nov', 12: 'Dez'
    })
    
    # Gr√°fico de sazonalidade
    fig = px.bar(
        stats_mes, x='mes_nome', y='mean',
        title='Sazonalidade por M√™s',
        labels={'mean': 'M√©dia de Ocorr√™ncias', 'mes_nome': 'M√™s'},
        color='mean',
        color_continuous_scale='Reds'
    )
    
    fig.update_layout(height=400)
    
    return fig, stats_mes

def create_trend_analysis(serie):
    """An√°lise de tend√™ncia"""
    # Calcula m√©dias m√≥veis
    window_3 = pd.Series(serie).rolling(window=3).mean()
    window_6 = pd.Series(serie).rolling(window=6).mean()
    window_12 = pd.Series(serie).rolling(window=12).mean()
    
    # Cria gr√°fico
    fig = go.Figure()
    
    datas = pd.date_range(start='2020-01-01', periods=len(serie), freq='MS')
    
    fig.add_trace(go.Scatter(
        x=datas, y=serie,
        name='S√©rie Original',
        line=dict(color='blue', width=2)
    ))
    
    fig.add_trace(go.Scatter(
        x=datas, y=window_3,
        name='M√©dia M√≥vel 3 meses',
        line=dict(color='red', width=2, dash='dash')
    ))
    
    fig.add_trace(go.Scatter(
        x=datas, y=window_6,
        name='M√©dia M√≥vel 6 meses',
        line=dict(color='green', width=2, dash='dash')
    ))
    
    fig.add_trace(go.Scatter(
        x=datas, y=window_12,
        name='M√©dia M√≥vel 12 meses',
        line=dict(color='orange', width=2, dash='dash')
    ))
    
    fig.update_layout(
        title='An√°lise de Tend√™ncia com M√©dias M√≥veis',
        xaxis_title='Data',
        yaxis_title='Ocorr√™ncias',
        height=500,
        hovermode='x unified'
    )
    
    return fig

def create_correlation_analysis(df):
    """An√°lise de correla√ß√£o temporal"""
    # Pivot para an√°lise de correla√ß√£o
    df_pivot = df.pivot_table(
        index='data', 
        columns='tipo_crime', 
        values='total_ocorrencias', 
        aggfunc='sum'
    ).fillna(0)
    
    # Matriz de correla√ß√£o
    corr_matrix = df_pivot.corr()
    
    # Gr√°fico de correla√ß√£o
    fig = px.imshow(
        corr_matrix,
        title='Correla√ß√£o entre Tipos de Crime',
        color_continuous_scale='RdBu',
        aspect='auto'
    )
    
    fig.update_layout(height=500)
    
    return fig, corr_matrix

def create_outlier_analysis(serie):
    """An√°lise de outliers"""
    # Calcula IQR
    Q1 = np.percentile(serie, 25)
    Q3 = np.percentile(serie, 75)
    IQR = Q3 - Q1
    
    # Identifica outliers
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    
    outliers = serie[(serie < lower_bound) | (serie > upper_bound)]
    
    # Gr√°fico de box plot
    fig = go.Figure()
    
    fig.add_trace(go.Box(
        y=serie,
        name='Distribui√ß√£o',
        boxpoints='outliers',
        marker=dict(color='red', size=8)
    ))
    
    fig.update_layout(
        title='An√°lise de Outliers',
        yaxis_title='Ocorr√™ncias',
        height=400
    )
    
    return fig, outliers, lower_bound, upper_bound

def main():
    """Fun√ß√£o principal"""
    st.title("üìà An√°lise Temporal - Tend√™ncias e Sazonalidade")
    st.markdown("An√°lise detalhada de tend√™ncias, sazonalidade e padr√µes temporais de viol√™ncia")
    
    # Carrega dados
    df = load_sample_data()
    
    # Sidebar com controles
    st.sidebar.title("üéõÔ∏è Controles")
    
    # Filtros
    crime_tipo = st.sidebar.selectbox(
        "Tipo de Crime:",
        ["Todos"] + df['tipo_crime'].unique().tolist()
    )
    
    regiao = st.sidebar.selectbox(
        "Regi√£o:",
        ["Todas"] + df['regiao_administrativa'].unique().tolist()
    )
    
    # Aplica filtros
    df_filtered = df.copy()
    
    if crime_tipo != "Todos":
        df_filtered = df_filtered[df_filtered['tipo_crime'] == crime_tipo]
    
    if regiao != "Todas":
        df_filtered = df_filtered[df_filtered['regiao_administrativa'] == regiao]
    
    # Agrega por data
    df_agg = df_filtered.groupby('data')['total_ocorrencias'].sum().reset_index()
    serie = df_agg['total_ocorrencias'].values
    
    # M√©tricas b√°sicas
    st.markdown("## üìä M√©tricas Temporais")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("Total de Registros", len(df_agg))
    
    with col2:
        st.metric("M√©dia Mensal", f"{serie.mean():.1f}")
    
    with col3:
        st.metric("Desvio Padr√£o", f"{serie.std():.1f}")
    
    with col4:
        st.metric("Coeficiente de Varia√ß√£o", f"{serie.std()/serie.mean()*100:.1f}%")
    
    # An√°lise de decomposi√ß√£o
    st.markdown("## üîç Decomposi√ß√£o da S√©rie Temporal")
    
    if st.button("üî¨ Executar Decomposi√ß√£o"):
        decomposition = decompose_time_series(serie)
        
        if decomposition:
            fig_decomp = create_decomposition_chart(decomposition)
            st.plotly_chart(fig_decomp, use_container_width=True)
            
            # Estat√≠sticas da decomposi√ß√£o
            st.markdown("### üìà Estat√≠sticas da Decomposi√ß√£o")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric("Vari√¢ncia da Tend√™ncia", f"{decomposition['trend'].var():.2f}")
            
            with col2:
                st.metric("Vari√¢ncia da Sazonalidade", f"{decomposition['seasonal'].var():.2f}")
            
            with col3:
                st.metric("Vari√¢ncia dos Res√≠duos", f"{decomposition['residual'].var():.2f}")
    
    # An√°lise de sazonalidade
    st.markdown("## üåä An√°lise de Sazonalidade")
    
    fig_season, stats_mes = create_seasonality_analysis(serie)
    st.plotly_chart(fig_season, use_container_width=True)
    
    # Tabela de sazonalidade
    st.markdown("### üìã Estat√≠sticas por M√™s")
    st.dataframe(stats_mes, use_container_width=True)
    
    # An√°lise de tend√™ncia
    st.markdown("## üìà An√°lise de Tend√™ncia")
    
    fig_trend = create_trend_analysis(serie)
    st.plotly_chart(fig_trend, use_container_width=True)
    
    # An√°lise de correla√ß√£o
    st.markdown("## üîó An√°lise de Correla√ß√£o")
    
    fig_corr, corr_matrix = create_correlation_analysis(df_filtered)
    st.plotly_chart(fig_corr, use_container_width=True)
    
    # Tabela de correla√ß√£o
    st.markdown("### üìã Matriz de Correla√ß√£o")
    st.dataframe(corr_matrix, use_container_width=True)
    
    # An√°lise de outliers
    st.markdown("## üéØ An√°lise de Outliers")
    
    fig_outlier, outliers, lower_bound, upper_bound = create_outlier_analysis(serie)
    st.plotly_chart(fig_outlier, use_container_width=True)
    
    # Estat√≠sticas de outliers
    st.markdown("### üìä Estat√≠sticas de Outliers")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric("N√∫mero de Outliers", len(outliers))
    
    with col2:
        st.metric("Limite Inferior", f"{lower_bound:.1f}")
    
    with col3:
        st.metric("Limite Superior", f"{upper_bound:.1f}")
    
    # Gr√°fico temporal completo
    st.markdown("## üìä S√©rie Temporal Completa")
    
    fig_complete = go.Figure()
    
    fig_complete.add_trace(go.Scatter(
        x=df_agg['data'],
        y=df_agg['total_ocorrencias'],
        mode='lines+markers',
        name='Ocorr√™ncias',
        line=dict(color='blue', width=2),
        marker=dict(size=6)
    ))
    
    # Adiciona linha de tend√™ncia
    z = np.polyfit(range(len(serie)), serie, 1)
    p = np.poly1d(z)
    fig_complete.add_trace(go.Scatter(
        x=df_agg['data'],
        y=p(range(len(serie))),
        mode='lines',
        name='Tend√™ncia',
        line=dict(color='red', width=2, dash='dash')
    ))
    
    fig_complete.update_layout(
        title='S√©rie Temporal com Tend√™ncia',
        xaxis_title='Data',
        yaxis_title='Ocorr√™ncias',
        height=500,
        hovermode='x unified'
    )
    
    st.plotly_chart(fig_complete, use_container_width=True)
    
    # Download
    st.markdown("## üíæ Download")
    
    csv = df_agg.to_csv(index=False)
    st.download_button(
        "üì• Download Dados Temporais CSV",
        csv,
        f"analise_temporal_{datetime.now().strftime('%Y%m%d')}.csv",
        "text/csv"
    )

if __name__ == "__main__":
    main()
